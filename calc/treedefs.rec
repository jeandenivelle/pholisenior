
%dir calc
%namespace calc

%define extension ( seq_blocking )

%option belief { seq_belief } => # name : logic::exact, visible : bool 
%option blocking { seq_blocking } => # nr : size_t 

%h_incl {
   #include "util/indentation.h"
   #include "logic/term.h" 
   #include "logic/exact.h"
}

%define proofterm ( prf_truthconst )
%option truthconst { prf_truthconst } =>
   // The truth constant (in Kleene logic).
%option tautology { prf_tautology } => fm : logic::term
%option exact { prf_exact } => exact : logic::exact
%option ident { prf_ident } => ident : identifier
%option clausify { prf_clausify } => parent : proofterm
%option orelim { prf_orelim } => parent : proofterm, nror : size_t,
      [ name : std::string, branch : proofterm ] 
%option existselim { prf_existselim } => 
               nrexists : size_t, parent : proofterm, 
               name : std::string, intro : proofterm 
%option expand { prf_expand } => 
   ident : identifier, occ : size_t, parent : proofterm 
%option forallelim { prf_forallelim } =>
   parent : proofterm, nrforall : size_t, [ value : logic::term ] 
%option define { prf_define } =>
   name : std::string, val : logic::term, parent : proofterm

%option magic { prf_magic } => goal : logic::term
%option show { prf_show } => comment : std::string, prf : proofterm


%h_incl {
   #include "sequent.h"
}

%h_before {
   bool very_equal( const std::vector< logic::term > & v1, const std::vector< logic::term > & v2 );
}

%h_methods {

   void print( indentation ind, std::ostream& out ) const;
}


%cpp_back
{
   void calc::proofterm::print( indentation ind, std::ostream& out ) const
   {
      switch( sel( ))
      {
      case prf_truthconst:
         out << ind << "truthconst\n";
         return; 

      case prf_ident:
         out << ind << "ident " << view_ident( ). ident( ) << "\n"; 
         return; 

      case prf_clausify:
         out << ind << "clausify\n";
         view_clausify( ). parent( ). print( ind + 3, out );
         return; 

      case prf_orelim:
         {
            auto elim = view_orelim( ); 
            out << ind << "orelim using subform " << elim. nror( ) << " in\n";
            elim. parent( ). print( ind + 3, out );  
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               out << ind << "branch " << i << ", call it ";
               out << elim. name(i) << " in\n";
               elim. branch(i). print( ind + 3, out );
            }
            return;
         }

      case prf_existselim:
         {
            auto elim = view_existselim( );
            out << ind << "existselim using subform ";
            out << elim. nrexists( ) << " in\n";
            elim. parent( ). print( ind + 3, out );
            out << ind << "as " << elim. name( ) << " in\n";
            elim. intro( ). print( ind + 3, out );
            return; 
         }

      case prf_expand:
         {
            auto exp = view_expand( );
            out << ind << "expand ";
            out << exp. ident( ) << ", occurrence " << exp. occ( ) << " in\n";
            exp. parent( ). print( ind + 3, out ); 
            return;  
         }

      case prf_define:
         {
            auto def = view_define( );
            out << ind << "define ";
            out << def. name( ) << " := " << def. val( ) << "\n";
            out << ind << "in\n";
            def. parent( ). print( ind + 3, out );
            return;
         }
 
      case prf_forallelim:
         {
            auto elim = view_forallelim( );
            out << ind << "forallelim using subform ";
            out << elim. nrforall( ) << "\n";
            out << ( ind + 3 ); 
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               if(i) out << ",  ";
               out << elim. value(i) << "\n";
            }
            out << ind << "on\n";
            elim. parent( ). print( ind + 3, out );
            return;
         }

      case prf_magic:
         {
            out << ind << "magic ";
            auto mag = view_magic( );
            out << mag. goal( ) << "\n";
            return;
         }

      case prf_show:
         {
            auto show = view_show( );
            out << ind << "show as ";
            out << show. comment( ) << "\n";
            show. prf( ). print( ind + 3, out );
            return;
         }

      }

      out << sel( ) << "\n";
      throw std::logic_error( "don't know how to print" );
   }

}

 
