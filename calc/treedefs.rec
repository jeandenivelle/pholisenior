
%dir calc
%namespace calc

%define extension ( seq_blocking )

%option belief { seq_belief } => # name : logic::exact, visible : bool 
%option blocking { seq_blocking } => # nr : size_t 

%h_incl {
   #include "util/indentation.h"
   #include "logic/term.h" 
   #include "logic/exact.h"
}

%define proofterm ( prf_truthconst ) 
%option truthconst { prf_truthconst } => 
%option triple { prf_triple } => fm : logic::term
%option cut { prf_cut } => 
   first : proofterm, name : std::string, second : proofterm
                          
%option ident { prf_ident } => ident : identifier
%option clausify { prf_clausify } => parent : proofterm

%option orelim { prf_orelim } => parent : proofterm, nror : size_t,
   [ name : std::string, branch : proofterm ] 
%option existselim { prf_existselim } => 
               parent : proofterm, nrexists : size_t, 
               name : std::string, intro : proofterm 

%option expand { prf_expand } => 
   ident : identifier, occ : size_t, parent : proofterm 

%option forallintro { prf_forallintro } =>
   parent : proofterm, [ var : logic::vartype ]
%option forallelim { prf_forallelim } =>
   parent : proofterm, nrforall : size_t, [ value : logic::term ] 

%option eqrepl { prf_eqrepl } =>
   parent : proofterm, times : size_t, [ eqnr : size_t, leftright : bool ]

%option define { prf_define } =>
   name : std::string, val : logic::term, parent : proofterm

%option andintro { prf_andintro } => [ parent : proofterm ]
%option select { prf_select } => parent : proofterm, [ nr : size_t ]

%option conflict { prf_conflict } => parent : proofterm 

%option fake { prf_fake } => goal : logic::term
%option show { prf_show } => comment : std::string, prf : proofterm

%h_incl {
   #include "sequent.h"
}

%h_before {
   bool very_equal( const std::vector< logic::term > & v1, const std::vector< logic::term > & v2 );
}

%h_methods {

   void print( indentation ind, std::ostream& out ) const;
}


%cpp_back
{
   void calc::proofterm::print( indentation ind, std::ostream& out ) const
   {
      switch( sel( ))
      {
      case prf_truthconst:
         out << ind << "truthconst\n";
         return; 

      case prf_ident:
         out << ind << "ident " << view_ident( ). ident( ) << "\n"; 
         return; 

      case prf_clausify:
         out << ind << "clausify\n";
         view_clausify( ). parent( ). print( ind + 3, out );
         return; 

      case prf_cut:
         {
            out << ind << "cut:\n";
            auto cut = view_cut( ); 
            cut. first( ). print( ind + 3, out );
            out << ind << "assumed as " << view_cut( ). name( ) << " in\n";
            cut. second( ). print( ind + 3, out );
            return;
         }

      case prf_orelim:
         {
            auto elim = view_orelim( ); 
            out << ind << "orelim using subform " << elim. nror( ) << " in\n";
            elim. parent( ). print( ind + 3, out );  
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               out << ind << "branch " << i << ", call it ";
               out << elim. name(i) << " in\n";
               elim. branch(i). print( ind + 3, out );
            }
            return;
         }

      case prf_existselim:
         {
            auto elim = view_existselim( );
            out << ind << "existselim using subform ";
            out << elim. nrexists( ) << " in\n";
            elim. parent( ). print( ind + 3, out );
            out << ind << "as " << elim. name( ) << " in\n";
            elim. intro( ). print( ind + 3, out );
            return; 
         }

      case prf_expand:
         {
            auto exp = view_expand( );
            out << ind << "expand ";
            out << exp. ident( ) << ", occurrence " << exp. occ( ) << " in\n";
            exp. parent( ). print( ind + 3, out ); 
            return;  
         }

      case prf_define:
         {
            auto def = view_define( );
            out << ind << "define ";
            out << def. name( ) << " := " << def. val( ) << "\n";
            out << ind << "in\n";
            def. parent( ). print( ind + 3, out );
            return;
         }

      case prf_forallintro:
         {
            auto intro = view_forallintro( );
            out << ind << "forallintro with";
            for( size_t i = 0; i != intro. size( ); ++ i )
            {
               if(i)
                  out << ", ";
               out << intro. var(i);
            }
            out << "\n";
            intro. parent( ). print( ind + 3, out );
            return; 
         }
 
      case prf_forallelim:
         {
            auto elim = view_forallelim( );
            out << ind << "forallelim using subform ";
            out << elim. nrforall( ) << "\n";
            out << ( ind + 3 ); 
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               if(i) out << ",  ";
               out << elim. value(i) << "\n";
            }
            out << ind << "on\n";
            elim. parent( ). print( ind + 3, out );
            return;
         }

      case prf_andintro:
         {
           auto intro = view_andintro( );
           out << ind << "andintro:\n";
           for( size_t i = 0; i != intro. size( ); ++ i )
           {
              intro. parent(i). print( ind + 3, out ); 
           }
           return;
         }

      case prf_select:
         {
            auto elim = view_select( );
            out << ind << "select";
            for( size_t i = 0; i != elim. size( ); ++ i )
            {
               if(i) 
                  out << ",";
               else
                  out << " ";

               out << elim. nr(i);
            }
            out << " from\n";
            elim. parent( ). print( ind + 3, out );
            return;
         }

      case prf_eqrepl:
         {
            auto repl = view_eqrepl( );
            out << ind << "replace";
            for( size_t i = 0; i != repl. size( ); ++ i )
            {
               if(i) 
                  out << ", ";
               else
                  out << " ";

               out << repl. eqnr(i) << ":";
               if( repl. leftright(i))
                  out << "L->R";
               else
                  out << "R->L";
            } 
            out << " trying " << repl. times( ) << " times"; 
            out << " in\n";
            repl. parent( ). print( ind + 3, out );
            return; 
         }

      case prf_conflict:
         {
            auto confl = view_conflict( );
            out << ind << "conflict\n";
            confl. parent( ). print( ind + 3, out );
            return;
         }

      case prf_fake:
         {
            out << ind << "faking ";
            auto mag = view_fake( );
            out << mag. goal( ) << "\n";
            return;
         }

      case prf_show:
         {
            auto show = view_show( );
            out << ind << "show as ";
            out << show. comment( ) << "\n";
            show. prf( ). print( ind + 3, out );
            return;
         }
      }

      out << sel( ) << "\n";
      throw std::logic_error( "don't know how to print" );
   }

}

 
